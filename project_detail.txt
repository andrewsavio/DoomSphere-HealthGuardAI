# HealthGuard AI - Project Continuity & Features Report

## Overview
HealthGuard AI is a comprehensive medical AI system that combines custom deep learning classification (DenseNet-121) with large language models to analyze medical scans, prioritize patient diagnosis severity, and generate human-readable medical reports. 

## Architectural Stack
1. *Backend API*: Flask (Python). Serves the native HTML pages and handles the /api/analyze REST endpoint.
2. *AI Image Classifier*: PyTorch (DenseNet-121) loaded from densenet_best_model.pth.
3. *Generative AI Vision*: Puter.js (gpt-5-nano) for fallback & multimodal vision checks without requiring paid LLM API keys. (Also supports Anthropic Claude and NVIDIA Clara models through API keys).
4. *Database & Storage*: Supabase (PostgreSQL). Stores users (profiles), conversations (chat_sessions, chat_messages), medical analysis metadata (scan_reports), and holds files in buckets (chat_images, reports).
5. *Frontend*: Native HTML/CSS/JS (Vanilla) for speed and cross-browser compatibility. No heavy frontend frameworks are required.
6. *PDF Generation*: fpdf and PyPDF2 (for PDF assembly and streaming compression) inside report_generator.py.

## Core Features Implemented

### 1. Dual-AI Analysis Pipeline
* *Specialized ML*: When an image (CT, MRI, X-ray) is uploaded via /analyze, the local PyTorch DenseNet model first identifies the scan type and detects anomalies, generating a Grad-CAM heatmap overlay to highlight areas of interest.
* *Generative AI*: The image and initial ML-findings are piped to a Generative AI prompt (using free Puter.js models or Groq APIs). Given a patient's symptoms and the ML model's output, it generates a human-friendly paragraph detailing severity, condition name, and layman translations.

### 2. Live Medical AI Chatbot
* Available at /chatbot, this page features a native UI chatbot that resembles conversational agents like ChatGPT.
* *Multimodal Uploads*: Users can attach medical scans directly to the chat. Files are temporarily uploaded to the Supabase chat_images bucket to procure a public HTTPS URL, which is then parsed by puter.ai.chat (powered by gpt-5-nano).
* *Session Persistence*: Chats are persisted to the Supabase chat_messages table and restored upon login.

### 3. Automated Cloud PDF Reports
* Upon analysis completion, the server automatically produces an extensive medical report in PDF format (report_generator.py).
* Before saving, PyPDF2 compresses the PDF's content streams losslessly.
* The PDF is instantly uploaded to the Supabase Storage bucket named reports.
* The frontend immediately serves a "Download PDF" button linked to the Supabase Content Delivery Network (CDN) URL.

### 4. Continuous Auto-Training
* The result of every medical scan analysis (whether it found an anomaly or not) is automatically sent back to the /api/train endpoint.
* This updates the system's feedback_stats dynamically over time, allowing the model to correct its internal weights and improve continuous performance globally.

### 5. Supabase Unified Authentication
* Global login and registration at /login.
* RLS (Row Level Security) is fully configured for users to only see their own chat sessions while anonymizing medical scan inputs.
* The frontend uses @supabase/supabase-js, injected straight into app.js via the environment variables loaded in /api/config.

## How to Continue Development
1. *Starting the Backend*: Ensure you have Python installed. Activate your local environment and run pip install -r requirements.txt. (Dependencies include flask, torch, torchvision, pillow, requests, fpdf, pypdf2, supabase). Start it by running python server.py.
2. *Environment Variables*: Make sure your .env contains project_url and anon_key pointing to your active Supabase instance, alongside any LLM API keys you wish to use as tier-2 fallbacks (Groq, Anthropic, Nvidia).
3. *Database Tweaks*: The SQL schemas are tracked in database.sql, database_v2.sql, database_v3.sql, and database_v4.sql. Run these sequentially in your Supabase SQL Editor if setting up a fresh database.
4. *Modifying Frontend*: All HTML pages (index.html, login.html, chatbot.html) route through vanilla JS files (app.js, chatbot.js). Styles are globally tracked in styles.css.